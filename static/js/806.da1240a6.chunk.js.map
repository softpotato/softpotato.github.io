{"version":3,"file":"static/js/806.da1240a6.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","state/lru_cache.js","state/post_storage.js","../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/inherits.js","../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/esm/createSuper.js","../node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","state/lru_key.js","state/utils.js","state/category_group.js","state/search_input.js","worker/search_worker.js"],"sourcesContent":["export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","/**\r\n * This class stores the data for the LRU Cache class.\r\n * It has 2 sets of pointers, denoted o for order and\r\n * h for hashMap. \r\n * \r\n * Order is meant for the access order pointers used to\r\n * maintain order of the nodes last used.\r\n * \r\n * HashMap is meant for the custom hash map nodes that\r\n * it stores it in, since the hash map expects collisions.\r\n * It uses a doubly linked list to maintain the references.\r\n * \r\n * Both systems use a doubly linked list pointer, since we\r\n * might access the Node by one set of pointers, but we'll\r\n * need to update both sets if we remove it.\r\n */\r\nclass LRUNode {\r\n    /**\r\n     * \r\n     * @param {LRUKey} key      - The key of the LRU Node\r\n     * @param {Object[]} value  - The value stored in the node\r\n     * @param {LRUNode} [oPrev] - the prev node in the ordered linked list\r\n     * @param {LRUNode} [oNext] - the next node in the ordered linked list\r\n     * @param {LRUNode} [hPrev] - The prev node in the hash map linked list\r\n     * @param {LRUNode} [hNext] - The next node in the hash map linekd list\r\n     */\r\n    constructor(key, value, oPrev, oNext, hPrev, hNext) {\r\n        this.key = key;\r\n        this.value = value;\r\n        this.oPrev = oPrev;\r\n        this.oNext = oNext;\r\n        this.hPrev = hPrev;\r\n        this.hNext = hNext;\r\n    }\r\n}\r\n\r\n/**\r\n * This is a Least Recently Used Cache. It's used to keep a minimal\r\n * storage of a pool of recently used data. It removes the least\r\n * recently used entry if the pool overfills. This is useful in OS,\r\n * but I think it's great for a simple way of preventing over caching \r\n * too much information.\r\n * \r\n * DESIGN\r\n * The design of this LRU cache is simple. It uses a simple linked\r\n * hash map. The oject keys need to have 1 parameter and 1 field,\r\n * the hashCode field and the equals() function. The hash map is\r\n * great for checking if an entry exists O(1) time. Within the hasmap\r\n * through is also a linked list. This doubly linked list connects\r\n * all stored nodes and has 2 dummy nodes at the start and end.\r\n * \r\n * Both the hash map and the linked lists have their own set of\r\n * nodes in each LRU Node, but the hash map is only a unidirectional\r\n * linked list. the least recently used linked list is a doubly linked\r\n * list.\r\n * \r\n * The doubly linked list is used to keep track of the usage sequence\r\n * of stored nodes.\r\n * \r\n * \r\n * This is a Least Recently Used Cache (LRU Cache) implementation.\r\n * This is used for storing the most important search results. This\r\n * isn't absolutely necessary for a client side approach, since\r\n * the client probably won't generate hundreds of thousands of\r\n * search queries. So, this is mostly better for server side, but\r\n * I'm adding this anyways.\r\n * \r\n * An LRU cache is implemented with a hash table and the hash table\r\n * contains double linked list pointers (e.g. can go forward and\r\n * backward).\r\n * \r\n * Also, another thing to note. Since our key is a compound key, and\r\n * we generated our own hash value. We need to be careful of collisions,\r\n * since we can't guarantee the key we used to insert into the Map is\r\n * unique.\r\n * \r\n * There are 2 approaches that I can think of for this issue.\r\n *  1) create a Map object, but store all collision entries in an\r\n *     array (e.g. buckets. Also called separate chaining)\r\n *  2) array form but use linear probing to insert entries, but makes\r\n *     worst case checking O(n) if the size of the array is too small.\r\n * \r\n * I'll do separate chaining again, so O(n) worst case search. Just cause\r\n * I haven't made it so I can rehash the whole table. \r\n * \r\n * ASSUMPTIONS: All inputs for the key entry requires the field \r\n * \"hashCode\" since this class doesn't hash the value itself. It\r\n * relies on the external class to supply a hash value.\r\n */\r\nexport default class LRUCache {\r\n\r\n    /**\r\n     * @param {number} maxsize - The max size of the LRU cache and\r\n     *                              the size of the hash map.\r\n     */\r\n    constructor(maxsize = 20) {\r\n\r\n        // Create Nodes to maintain order of access linked list\r\n        const startDummyNode = new LRUNode(null, null);\r\n        const endDummyNode = new LRUNode(null, null);\r\n        startDummyNode.oNext = endDummyNode;\r\n        endDummyNode.oPrev = startDummyNode;\r\n\r\n        // initialize fields\r\n        this.maxsize = maxsize > 0 ? maxsize : 20;\r\n        this.size = 0;\r\n        this.table = Array(maxsize).fill(null);\r\n        this.start = startDummyNode;\r\n        this.end = endDummyNode\r\n\r\n        // Initializes each array entry to have a node\r\n        for (let i = 0; i < this.table.length; i++) {\r\n            this.table[i] = new LRUNode(null, null);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * This function inserts a value into the LRU cache and stores it.\r\n     * It will also remove an old entry if it exceeds the maxsize.\r\n     * \r\n     * @param {LRUKey} key \r\n     * @param {Object} value \r\n     */\r\n    insert(key, value) {\r\n        if (key == null || value == null) return;\r\n\r\n        // we can assume that the table entry already has an entry.\r\n        let node = this.table[this.generateHashIndex(key.hashCode)];\r\n\r\n        while (node.hNext != null) {\r\n            node = node.hNext;\r\n\r\n            // If the key is already in storage\r\n            if (node.key.equals(key)) {\r\n\r\n                // rotate to front\r\n                this.removeAndAddToStart(node);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // we can now assume node is right before end of list, so insert in\r\n        const newNode = new LRUNode(key, value);\r\n\r\n        // update hash map references\r\n        node.hNext = newNode;\r\n        newNode.hPrev = node;\r\n\r\n        // update order references\r\n        this.addToLinkedListHead(newNode);\r\n    }\r\n\r\n    /**\r\n     * This function is called when either inserting a duplicate\r\n     * entry found (e.g. we put it at the head of the linked list),\r\n     * or when we call a retrieve.\r\n     * @param {LRUNode} node \r\n     */\r\n    removeAndAddToStart(node) {\r\n\r\n        // If not already at the start\r\n        if (node.oPrev.key != null) {\r\n            node.oNext.oPrev = node.oPrev;\r\n            node.oPrev.oNext = node.oNext;\r\n            node.oNext = this.start.oNext;\r\n            node.oPrev = this.start;\r\n            this.start.oNext.oPrev = node;\r\n            this.start.oNext = node;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * This function adds the node to the\r\n     * head of the access order linked list. \r\n     * It assumes that the node is not already\r\n     * in the linked list.\r\n     * \r\n     * @param {LRUNode} node \r\n     */\r\n    addToLinkedListHead(node) {\r\n\r\n        // Increment size\r\n        this.size++;\r\n\r\n        // updates pointers\r\n        node.oNext = this.start.oNext;\r\n        node.oPrev = this.start;\r\n        this.start.oNext.oPrev = node;\r\n        this.start.oNext = node;\r\n\r\n        // checks for overflow\r\n        if (this.size > this.maxsize) {\r\n            this.size--;\r\n\r\n            // Remove the last node from it's pointers\r\n            const lastNode = this.end.oPrev;\r\n\r\n            // updates ordered linked list\r\n            lastNode.oPrev.oNext = lastNode.oNext;\r\n            lastNode.oNext.oPrev = lastNode.oPrev;\r\n\r\n            // updates hash map linked list\r\n            lastNode.hPrev.hNext = lastNode.hNext;\r\n            if (lastNode.hNext != null) { // hash map linked list only has 1 dummy node, so can't assume next one has.\r\n                lastNode.hNext.hPrev = lastNode.hPrev;\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * This function checks if the given key exists in the \r\n     * map.\r\n     * \r\n     * @param {LRUKey} key \r\n     */\r\n    has(key) {\r\n        if (key == null) {\r\n            return false;\r\n        }\r\n\r\n        let node = this.table[this.generateHashIndex(key.hashCode)];\r\n        while (node.hNext != null) {\r\n            node = node.hNext;\r\n\r\n            if (node.key.equals(key)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return node.key != null ? key.equals(node.key) : false;\r\n    }\r\n\r\n    /**\r\n     * This function returns the stored cache information mapped to the\r\n     * key object.\r\n     * \r\n     * @param {LRUKey} key \r\n     * @returns \r\n     */\r\n    retrieve(key) {\r\n        \r\n        if (key == null) {\r\n            return null;\r\n        }\r\n\r\n        let node = this.table[this.generateHashIndex(key.hashCode)];\r\n\r\n        while (node.hNext != null) {\r\n            node = node.hNext;\r\n\r\n            if (node.key.equals(key)) {\r\n                this.removeAndAddToStart(node);\r\n                return node.value;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n\r\n    /**\r\n     * Since we have our own built in\r\n     * hash table, we need to map the\r\n     * bins to their corresponding \r\n     * \r\n     * @param {number} hashCode \r\n     */\r\n    generateHashIndex(hashCode) {\r\n        return hashCode % this.maxsize;\r\n    }\r\n\r\n\r\n}","import LRUCache from \"./lru_cache\";\r\n\r\n/**\r\n * These functions are mutators. They don't\r\n * return anything. They just mutate the passed\r\n * in array. \r\n * \r\n * It assumes x is an array.\r\n * \r\n * It assumes ascending is boolean.\r\n */\r\nconst sortFunctions = {\r\n    \"bestMatch\": function (x, ascending = true, keyword = \"potato\") {\r\n\r\n        // Some error we need to worry about. Sort best by keyword\r\n        // doesn't work if there is no keyword. We need this function\r\n        // to have a default functionality if there is no keyword\r\n        // passed in. (e.g. keyword = \"\"). You can't sort this at all\r\n        // so we'll do it by title. \r\n\r\n        if (keyword !== \"\") {\r\n            x.sort(function (a, b) {\r\n                // This function sucks. This iterates through the whole\r\n                // post to hopefully find matching key words.\r\n\r\n                // So we'll need to traverse the post content. The content is\r\n                // a nested tree stored in the \"pages\" field. It can take on\r\n                // the following structure\r\n                //\r\n                //  pages: [\r\n                //      {\r\n                //          content: \"string to parse\",\r\n                //          sections: [\r\n                //              {\r\n                //                  content: \"content stuff or image file name\",\r\n                //                  alt-text: \"alternate image text\"\r\n                //              },\r\n                //              {\r\n                //                  content: \"drop down list\",\r\n                //                  sections: [\r\n                //                      {\r\n                //                          content: \"this is nested\"    \r\n                //                      }, ...\r\n                //                  ]\r\n                //              },\r\n                //              {\r\n                //                  sections: [\r\n                //                      {\r\n                //                          content: \"code here\"\r\n                //                      },...\r\n                //                  ]\r\n                //              }\r\n                //          ]\r\n                //      },\r\n                //      ...\r\n                //  ]\r\n                //\r\n                // The content can be nested an infinite amount of times, but in general\r\n                // unless some wacko decides to put a drop down in a drop down in a drop down,\r\n                // normal case should be safe to assume depth of 3 at most for most posts.\r\n                // \r\n                // - The pages object is the root element containing all nested children.\r\n                // - The sections field are optional fields that are guaranteed on the\r\n                //      first depth of the pages object. On first depth, sections contains\r\n                //      the primary elements displayed. On second or later depths, they\r\n                //      contain object type specific content that is dependent on the rendered type.\r\n                //      not all objects within the first depth can guarantee sections content.\r\n                // - content field is OPTIONAL and the only field that the regex search should be performed on.\r\n\r\n                // Can optimize to cache these expensive operations.\r\n                const aHit = sortFunctions.stringHitCount(keyword, a);\r\n                const bHit = sortFunctions.stringHitCount(keyword, b);\r\n\r\n                return bHit - aHit;\r\n\r\n\r\n            });\r\n            return x;\r\n\r\n        } else { // if no valid keyword posted in, sort by date uploaded.\r\n            // copy pased code from the \"datePosted\" function for default behavior\r\n            x.sort(function (a, b) {\r\n                const dateA = Date.parse(a.created);\r\n                const dateB = Date.parse(b.created);\r\n\r\n                if (dateA < dateB) {\r\n                    return -1 * (ascending ? 1 : -1);\r\n                } else if (dateB < dateA) {\r\n                    return 1 * (ascending ? 1 : -1);\r\n                } else {\r\n                    return 0;\r\n                }\r\n            });\r\n\r\n            return x;\r\n        }\r\n    },\r\n    \"title\": function (x, ascending = true, keyword = \"potato\") {\r\n        x.sort(function (a, b) {\r\n            return a.title.localeCompare(b.title) * (ascending ? 1 : -1);\r\n        });\r\n\r\n        return x;\r\n    },\r\n    \"datePosted\": function (x, ascending = true, keyword = \"potato\") {\r\n        x.sort(function (a, b) {\r\n            const dateA = Date.parse(a.created);\r\n            const dateB = Date.parse(b.created);\r\n\r\n            if (dateA < dateB) {\r\n                return -1 * (ascending ? 1 : -1);\r\n            } else if (dateB < dateA) {\r\n                return 1 * (ascending ? 1 : -1);\r\n            } else {\r\n                return 0;\r\n            }\r\n        });\r\n\r\n        return x;\r\n    },\r\n    \"lastEdited\": function (x, ascending = true, keyword = \"potato\") {\r\n        x.sort(function (a, b) {\r\n            const dateA = Date.parse(a.updated);\r\n            const dateB = Date.parse(b.updated);\r\n\r\n            if (dateA < dateB) {\r\n                return -1 * (ascending ? 1 : -1);\r\n            } else if (dateB < dateA) {\r\n                return 1 * (ascending ? 1 : -1);\r\n            } else {\r\n                return 0;\r\n            }\r\n        });\r\n\r\n        return x;\r\n    },\r\n    stringHitCount: function (searchStr, postObject) {\r\n\r\n        /**\r\n         * This function uses a regex expression to iterate through\r\n         * and search for matching cases.\r\n         */\r\n        const regexExpression = new RegExp(searchStr.replace(/ +/g, \"|\"), \"gi\");\r\n        let hit = 0;\r\n\r\n        // check the title and description of the post\r\n        hit += ((postObject[\"title\"] || \"\").match(regexExpression) || []).length;\r\n\r\n        hit += ((postObject[\"description\"] || \"\").match(regexExpression) || []).length;\r\n\r\n        // Iterate through all post pages\r\n        for (let index in postObject.pages) {\r\n            const postElement = postObject.pages[index];\r\n            // need to recursively DFS check if any hits\r\n            hit += this.dfsCheckContent(regexExpression, postElement);\r\n        }\r\n\r\n        return hit;\r\n\r\n    },\r\n    dfsCheckContent(regexExp, postElement) {\r\n        if (postElement == null) {\r\n            return 0;\r\n        }\r\n\r\n        let count = 0;\r\n\r\n        if (Object.hasOwn(postElement, 'content')) {\r\n            count += ((postElement['content'] || \"\").match(regexExp) || []).length;\r\n        }\r\n\r\n        if (Object.hasOwn(postElement, 'sections')) {\r\n            for (let nestedPostEl in postElement['sections']) {\r\n                count += this.dfsCheckContent(regexExp, nestedPostEl);\r\n            }\r\n        }\r\n\r\n        return count;\r\n    }\r\n};\r\n\r\n\r\n/**\r\n * This class manages storing, organizing, and caching\r\n * search information given a pool of all available posts.\r\n * This class assumes a pool of unfiltered posts will be \r\n * given to it on initialization. \r\n * \r\n * This class is intended to be stored in the web worker\r\n * and used mostly for generating queries. \r\n * \r\n * Groupings\r\n *      type - the main focus of the \r\n *          tutorial\r\n *          project\r\n *          tool\r\n *          game\r\n *          other\r\n *          * should be generated through content\r\n *      tags - these are more general descriptors for the content\r\n *          intro\r\n *          advanced\r\n *          React.js\r\n *          Redux\r\n *          Flux\r\n *          Konvas\r\n *          Front End\r\n *          Back End\r\n *          Full Stack\r\n *          Data Science\r\n *          Object Oriented Programming\r\n *          Fundamentals\r\n *          Refresher\r\n *          video game guide\r\n *          theory\r\n *          proof\r\n *          * can be anything, but maybe APIs used might be helpful\r\n *          * also should be generated by the given content\r\n *      programming language - the programming language used in the post\r\n *          none\r\n *          JavaScript\r\n *          Python\r\n *          C++\r\n *          C\r\n *          C#\r\n *          Java\r\n *          * should also be generated by the given content\r\n *      publication status\r\n *          ongoing\r\n *          completed\r\n *          not started\r\n *          cancelled\r\n *          hiatus\r\n *      language\r\n *          English\r\n *          Japanese\r\n *          Chinese\r\n *          French\r\n *          * I can only read/write in English. I guess I'm doing Duolingo in Japanese and\r\n *            I did French in middle/high school. However, I sucked at it so probably won't\r\n *            translate my posts to other languages.\r\n * \r\n */\r\nexport default class PostStorage {\r\n\r\n    /**\r\n     * This function takes in a single Object. This\r\n     * object contains objects within it each keyed \r\n     * through a key value starting from 1. \r\n     * \r\n     * @param {Object} jsonObjects - posts to be stored and sorted.\r\n     */\r\n    constructor(jsonObjects) {\r\n\r\n        this.unfilteredPosts = jsonObjects; // store Objects reference in class\r\n\r\n        // Grouping\r\n        //  The following are JavaScript objects. I use objects since these don't\r\n        //  change all too frequently. Also, I read a post on when to use Map vs Object.\r\n        //  I use objects since this is a high read low mutation situation after initialization.\r\n        //  https://stackoverflow.com/questions/66931535/javascript-object-vs-map-set-key-lookup-performance#:~:text=Use%20Maps%20for%20dictionaries%20with%20lots%20of%20different%2C,caching%2C%20hidden%20classes%20with%20fixed%20memory%20layout%20etc.%29\r\n        this.typeGroups = Object.create(null); // we don't need any of these extra properties offered by \r\n        this.tagGroups = Object.create(null);   // prototype\r\n        this.programmingLanguageGroups = Object.create(null);\r\n        this.publicationStatusGroups = Object.create(null);\r\n        this.languageGroups = Object.create(null);\r\n\r\n        // Initializes default fields that need to be in there.\r\n        this.typeGroups[\"tutorial\"] = [];\r\n        this.typeGroups[\"project\"] = [];\r\n        this.typeGroups[\"tool\"] = [];\r\n        this.typeGroups[\"other\"] = [];\r\n        this.publicationStatusGroups[\"completed\"] = [];\r\n        this.publicationStatusGroups[\"ongoing\"] = [];\r\n        this.publicationStatusGroups[\"not started\"] = [];\r\n        this.publicationStatusGroups[\"cancelled\"] = [];\r\n        this.publicationStatusGroups[\"hiatus\"] = [];\r\n        this.languageGroups[\"english\"] = [];\r\n\r\n        // This function iterates through and creates groupings.\r\n        for (let key in jsonObjects) {\r\n            const obj = jsonObjects[key];   // get object reference\r\n\r\n            // Registers it with typeGroups\r\n            const ty_lc = obj.type.toLowerCase(); // converts to lower case\r\n            if (ty_lc in this.typeGroups) {\r\n                this.typeGroups[ty_lc].push(key);\r\n            } else {\r\n                this.typeGroups[ty_lc] = [key];\r\n            }\r\n\r\n            // Registers it with tagGroups\r\n            for (let index in obj.tags) {\r\n                const t_lc = obj.tags[index].toLowerCase(); // lowercase converted\r\n\r\n                if (t_lc in this.tagGroups) {\r\n                    this.tagGroups[t_lc].push(key);\r\n                } else {\r\n                    this.tagGroups[t_lc] = [key];\r\n                }\r\n            }\r\n\r\n            // Registers it with programmingLanguageGroups\r\n            for (let index in obj.programming_languages) {\r\n                const pl_lc = obj.programming_languages[index].toLowerCase(); // lowercase converted\r\n\r\n                if (pl_lc in this.programmingLanguageGroups) {\r\n                    this.programmingLanguageGroups[pl_lc].push(key);\r\n                } else {\r\n                    this.programmingLanguageGroups[pl_lc] = [key];\r\n                }\r\n            }\r\n\r\n            // Registers it with publicationStatusGroup\r\n            const s_lc = obj.status.toLowerCase();\r\n            if (s_lc in this.publicationStatusGroups) {\r\n                this.publicationStatusGroups[s_lc].push(key);\r\n            } else {\r\n                this.publicationStatusGroups[s_lc] = [key];\r\n            }\r\n\r\n            // Registers it with languageGroups\r\n            const lg_lc = obj.language.toLowerCase();\r\n            if (lg_lc in this.languageGroups) {\r\n                this.languageGroups[lg_lc].push(key);\r\n            } else {\r\n                this.languageGroups[lg_lc] = [key];\r\n            }\r\n\r\n        }\r\n\r\n        // Sorts and organizes the data\r\n        //  definitely not efficient, but if we have\r\n        //  this run by a web agent. We can have this\r\n        //  process run in the background.\r\n        //\r\n        //  In general though, you want this process running\r\n        //  on the server at probably consistent intervals to\r\n        //  keep all data up to date. This is a heafty operation,\r\n        //  but it should keep the amount of in search processing\r\n        //  to a minimum.\r\n        for (let key in this.typeGroups) {\r\n            this.typeGroups[key].sort();\r\n        }\r\n\r\n        for (let key in this.tagGroups) {\r\n            this.tagGroups[key].sort();\r\n        }\r\n\r\n        for (let key in this.programmingLanguageGroups) {\r\n            this.programmingLanguageGroups[key].sort();\r\n        }\r\n\r\n        for (let key in this.publicationStatusGroups) {\r\n            this.publicationStatusGroups[key].sort();\r\n        }\r\n\r\n        for (let key in this.languageGroups) {\r\n            this.languageGroups[key].sort();\r\n        }\r\n\r\n        // Prepares Caching Bins\r\n        this.intersectionCache = new LRUCache(20); // stores merged union of sorted data sets.\r\n\r\n        /**\r\n         * Caching information post note\r\n         * \r\n         * There is only 1 cache in this storage, since message passing between\r\n         * web workers is expensive. I'm caching completed search results external\r\n         * to this class. Only intermediate value information gets cached here.\r\n         */\r\n\r\n    }\r\n\r\n    /**\r\n     * This function returns a 2D array of string values\r\n     * storing all the tags in the current dataset. This \r\n     * is used for generating the tag listings for the\r\n     * advanced search in the advanced search page.\r\n     * This should be called right after initialization\r\n     * since I can't return a value in the constructor,\r\n     * this is meant to be passed back immediately through\r\n     * the web worker. The values in the arrays are copied\r\n     * to avoid destroying the groups upon message back.\r\n     * \r\n     * @returns {string[][]} tagArray\r\n     */\r\n    getTags() {\r\n\r\n\r\n        return [\r\n            [...Object.keys(this.typeGroups)],\r\n            [...Object.keys(this.tagGroups)],\r\n            [...Object.keys(this.programmingLanguageGroups)],\r\n            [...Object.keys(this.publicationStatusGroups)],\r\n            [...Object.keys(this.languageGroups)]\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * This function checks the cache for a pre-generated search data. There are\r\n     * 2 caches that it checks, before generating the data from scratch. It then\r\n     * returns the completed search result as an array for rendering.\r\n     * \r\n     * @param {SearchInput} searchObject - This object contains all search parameters\r\n     *                                      passed in by the user. This parameter\r\n     *                                      REQUIRES a SearchInput object. The web worker\r\n     *                                      needs to convert back the passed in values to\r\n     *                                      work properly.\r\n     */\r\n    search(searchObject) {\r\n\r\n        /**\r\n         * WARNING: Terrible coding practices ahead.\r\n         * \r\n         * Okay, so I admit I did something completely devoid of logic.\r\n         * I decided to use an array to store the intersected data, but I\r\n         * thought. WOW, JavaScripts lets me store whatever I want in the\r\n         * array, unlike Java. So I decided to mutate the array. Turns out,\r\n         * I also cached the mutated array and now it's fucking everything\r\n         * up. Several tests later, and I finally come back to this abomindation\r\n         * of code. \r\n         * \r\n         * FML.\r\n         */\r\n\r\n        // Part 1 - Check intersection cache for partially completed result\r\n        let intersectedData = this.intersectionCache.retrieve(searchObject.categoryGroup);\r\n\r\n        // If no merged data set is found, then generate it and store it in LRU Cache\r\n        if (intersectedData == null) {\r\n\r\n            intersectedData = this.generateIntersectionData(searchObject.categoryGroup);\r\n            this.intersectionCache.insert(searchObject.categoryGroup, [...intersectedData]);\r\n        } else {\r\n            intersectedData = [...intersectedData]; // due to error mentioned above\r\n        }\r\n\r\n        // Part 2 - Convert Key Dataset to posts\r\n        //  The previous steps generated an array of key values for the posts,\r\n        //  but we'll need to store the posts based on the metadata information.\r\n\r\n        // This iteration replaces all previous entries with the raw object information.\r\n        for (let i = 0; i < intersectedData.length; i++) {\r\n            intersectedData[i] = this.unfilteredPosts[intersectedData[i]];\r\n        }\r\n\r\n        // Part 3 - Sorting\r\n\r\n        // Sorting is probably gonna be a crap fest. There are 5 sort methods\r\n        // and we'll need to do them both ways, so 10 different sort methods.\r\n        // They are as follows\r\n        //      1) Most matches (given the keyword, which post has the most matches)\r\n        //      2) title (sorted by title order)\r\n        //      3) date posted (when the original post was made)\r\n        //      4) last edited (when the post was last edited, if at all)\r\n        //      5) author (nvm, we're not doing this. Only if you had a server full of posts, maybe. But not here.)\r\n\r\n        // So we're given a string that says the sort order we'll use. We could use\r\n        // a switch, but that is O(n) worst cast time complexity to find the right\r\n        // formula. We might as well use a hash map in this case as well, since this\r\n        // is a functional programming language (e.g. functions are first class citizens).\r\n        // we can store a function as a lambda function and call it in the hash map.\r\n        // Actually, you'd do this in Python. Since this is JavaScript, we can just\r\n        // have the string call directly a function stored in an object (which is\r\n        // also a hashMap... I think...)\r\n\r\n        // If a valid search method was passed in\r\n        if (Object.hasOwn(sortFunctions, searchObject.sortBy)) {\r\n            sortFunctions[searchObject.sortBy](intersectedData, searchObject.ascending, searchObject.keyword);\r\n\r\n        } else { // Invalid search results in default behavior of sort by date posted\r\n            console.error(\"Invalid sort function passed in. Default sort by title.\");\r\n            sortFunctions[\"datePosted\"](intersectedData, searchObject.ascending, searchObject.keyword);\r\n        }\r\n\r\n        // Part 4 - Filtering\r\n        // I am stumped. \r\n        // Okay, so keywords the user enters into the search bar are NOT necessary for most sorts.\r\n        // sort by date and sort by title don't require the keywords, they filter the output\r\n        // for it. \r\n        // Sort by best match requires the keywords, so the keyword is used.\r\n\r\n        // In general, if this had a server client, then it's generally not a good idea to\r\n        // send the user extra post data. However, users might change their keyword search\r\n        // so the UI would handle that instead of the server, so it might be better to\r\n        // send a little more extra data the UI handles instead. Although, I guess this\r\n        // is a static webpage, so I don't really need to worry about this type of interaction.\r\n        // However, sorting and filtering are expensive. Sorting is O(n log(n)), but with\r\n        // sort by best match. It's probably O((nm) log (nm)) where m is the max size of\r\n        // a post, since we'll need to parse the posts using regex expressions. This\r\n        // might make searching on this static webpage REALLY REALLY slow. I was thinking\r\n        // that it might be best to cache the result inbetween the Sort and Filter stages\r\n        // (step 3 and step 4), but then that requires a new intermediate class and I'll\r\n        // need a way to handle sort by best match independent of this implementation.\r\n        // The reason for that is because search_input.js hashes the key value on initialization\r\n        // alongside the search keywords the user input. But, if I wanted to cache the\r\n        // result inbetween the 2 steps, then I'll need to alter either the class structure\r\n        // of data alterations or expectations and do something like the category_group.js\r\n        // where I hash that set of data separately. \r\n\r\n        // My brain is burnt. I'm just going to filter this output and cache the result.\r\n        // RIP. poor foresight has resulted in this. Hopefully typing in the search\r\n        // bar won't result in too much of a lag spike.\r\n\r\n        // This operation is O(nm), where n is the number of posts and m is the max\r\n        // size of a post or whatever the regex time to parse a post is. Honestly\r\n        // not sure how efficient regex expressions are so I call them m. However,\r\n        // maybe it's a little too excessive to parse the whole post. Maybe I can\r\n        // create a system for a better cache inbetween search and result?\r\n\r\n        // Fuck, gotta stop overthinking this. I've been here for 5-7 hours just\r\n        // pondering on this. Gosh darn it. Time flies when you're sick.\r\n\r\n        let filteredDisplayList = []; // This array is the one sent to the UI\r\n\r\n        // simple iteration filter.\r\n        if (searchObject.keyword !== \"\") {\r\n            for (let index in intersectedData) {\r\n                const post = intersectedData[index];\r\n                if (sortFunctions.stringHitCount(searchObject.keyword, post) >= 1) {\r\n                    filteredDisplayList.push(post);\r\n                }\r\n            }\r\n        } else {\r\n            filteredDisplayList = intersectedData;\r\n        }\r\n\r\n        // output\r\n        return filteredDisplayList;\r\n\r\n    }\r\n\r\n    /**\r\n     * This function sums together the length of all the 2nd \r\n     * dimension of the array. E.g.\r\n     *  [\r\n     *      [\"1\",\"2\",\"3\"],\r\n     *      [\"4\",\"5\",\"6\"]\r\n     *  ]\r\n     * would return 6.\r\n     * \r\n     * This is used for checking if there is a tag\r\n     * constraint passed in the search input. If there\r\n     * isn't, then it returns everything.\r\n     * \r\n     * An alternative write might be to use either the\r\n     * reduce function, but you'd have to mash all arrays\r\n     * together then take it's length. \r\n     * \r\n     * @param {string[][]} array \r\n     */\r\n    helperGet2dArrayLength(array) {\r\n        let len = 0;\r\n        for (let row = 0; row < array.length; row++) {\r\n            for (let column = 0; column < array[row].length; column++) {\r\n                len++;\r\n            }\r\n        }\r\n        return len;\r\n    }\r\n\r\n    /**\r\n     * This function generates the intersection tag data.\r\n     * \r\n     * UPDATE\r\n     * Okay, so the name sucks. I confused this with another\r\n     * function. So this function does NOT generate ONLY\r\n     * intersection in the search queries. It handles both\r\n     * the Intersection and Union of the data sets. It's\r\n     * mostly responsible for mashing the 2 together.\r\n     * \r\n     * DEBUGGING\r\n     * So to add more detail on what the fuck I was writing\r\n     * when I made this. It's a helper function that mashes\r\n     * together all the tags in the inclusion and exclusion\r\n     * data set and creates a single list.\r\n     * \r\n     * @param {CategoryGroup} tagSelections - This object contains tags the user selected.\r\n     */\r\n    generateIntersectionData(tagSelections) {\r\n        // Part 1 - Generate Inclusion Data\r\n\r\n        // The tags we have in tagSelections are only the key names of\r\n        // the actual sorted and grouped entry values. We need to convert\r\n        // these keys to arrays of post keys.\r\n\r\n        // Random Note:\r\n        //      I'm not sure if is more efficient to generate a 2d array o\r\n        //      entries to merge, then merge them. Or to just iterate over\r\n        //      using a hashset and add them. The issue though is the AND\r\n        //      operation, since it requires it to be in both data sets. It\r\n        //      would be more difficult since we would need to keep a running\r\n        //      list of tags that have been touched or not per layer. Maybe\r\n        //      a hashset of index values that only increment if the previous\r\n        //      hit occured and we can just iterate through for only the ones\r\n        //      with the final index value sum. \r\n\r\n        // This array is used to store each array of keys\r\n        let entriesToMerge = [];\r\n\r\n        // Iterate through the typeGroup keys\r\n        for (let index in tagSelections.iTags[0]) {\r\n            const typeTag = tagSelections.iTags[0][index];\r\n\r\n            // add to entries ONLY if it exists \r\n            if (typeTag in this.typeGroups) {\r\n                entriesToMerge.push(this.typeGroups[typeTag]);\r\n            }\r\n        }\r\n\r\n        // Iterate through the tags that are explicitly for tagging data\r\n        // (apologies for the confusing name. Brain can't handle naming things.)\r\n        for (let index in tagSelections.iTags[1]) {\r\n            const tagTag = tagSelections.iTags[1][index];\r\n            if (tagTag in this.tagGroups) {\r\n                entriesToMerge.push(this.tagGroups[tagTag]);\r\n            }\r\n        }\r\n\r\n        // Iterate through programming languages\r\n        for (let index in tagSelections.iTags[2]) {\r\n            const pgTag = tagSelections.iTags[2][index];\r\n            if (pgTag in this.programmingLanguageGroups) {\r\n                entriesToMerge.push(this.programmingLanguageGroups[pgTag]);\r\n            }\r\n        }\r\n\r\n        // Iterate through publication status\r\n        for (let index in tagSelections.iTags[3]) {\r\n            const psTag = tagSelections.iTags[3][index];\r\n            if (psTag in this.publicationStatusGroups) {\r\n                entriesToMerge.push(this.publicationStatusGroups[psTag]);\r\n            }\r\n        }\r\n\r\n        // Iterate through languages group\r\n        for (let index in tagSelections.iTags[4]) {\r\n            const lgTag = tagSelections.iTags[4][index];\r\n            if (lgTag in this.languageGroups) {\r\n                entriesToMerge.push(this.languageGroups[lgTag]);\r\n            }\r\n        }\r\n\r\n        // performs the merge operation between the converted data\r\n        let inclusionDataset = null;\r\n\r\n        // If it has no tag constraints, then add the whole tag pool in\r\n        if (this.helperGet2dArrayLength(tagSelections.iTags) === 0) {\r\n            inclusionDataset = Object.keys(this.unfilteredPosts);\r\n\r\n            // If it is an intersection tag constraint\r\n        } else if (tagSelections.iAnd) {\r\n            inclusionDataset = this.generateIntersection(entriesToMerge);\r\n\r\n            // If it is a union tag constraint\r\n        } else {\r\n            inclusionDataset = this.generateUnion(entriesToMerge);\r\n        }\r\n\r\n        // Part 2 - Generates the exclude data\r\n        entriesToMerge = [];    // reusing this, cause might as well.\r\n\r\n        // Iterate through the typeGroup keys\r\n        for (let index in tagSelections.eTags[0]) {\r\n            const typeTag = tagSelections.eTags[0][index];\r\n            if (typeTag in this.typeGroups) {\r\n                entriesToMerge.push(this.typeGroups[typeTag]);\r\n            }\r\n        }\r\n\r\n        // Iterate through the tags that are explicitly for tagging data\r\n        // NO APOLOGIES!\r\n        for (let index in tagSelections.eTags[1]) {\r\n            const tagTag = tagSelections.eTags[1][index];\r\n            if (tagTag in this.tagGroups) {\r\n                entriesToMerge.push(this.tagGroups[tagTag]);\r\n            }\r\n        }\r\n\r\n        // Iterate through programming languages\r\n        for (let index in tagSelections.eTags[2]) {\r\n            const pgTag = tagSelections.eTags[2][index];\r\n            if (pgTag in this.programmingLanguageGroups) {\r\n                entriesToMerge.push(this.programmingLanguageGroups[pgTag]);\r\n            }\r\n        }\r\n\r\n        // Iterate through publication status\r\n        for (let index in tagSelections.eTags[3]) {\r\n            const psTag = tagSelections.eTags[3][index];\r\n            if (psTag in this.publicationStatusGroups) {\r\n                entriesToMerge.push(this.publicationStatusGroups[psTag]);\r\n            }\r\n        }\r\n\r\n        // Iterate through languages group\r\n        for (let index in tagSelections.eTags[4]) {\r\n            const lgTag = tagSelections.eTags[4][index];\r\n            if (lgTag in this.languageGroups) {\r\n                entriesToMerge.push(this.languageGroups[lgTag]);\r\n            }\r\n        }\r\n\r\n        // performs the merge operation between the converted data\r\n        let exclusionDataset = null;\r\n\r\n        if (tagSelections.eAnd) {\r\n            exclusionDataset = this.generateIntersection(entriesToMerge);\r\n        } else {\r\n            exclusionDataset = this.generateUnion(entriesToMerge);\r\n        }\r\n\r\n        // Part 3 - Filter out excluded data from included data\r\n        // Note: we can assume that the 2 data sets are alphanumerically\r\n        // sorted, since the merge preserved sort order. We can simply\r\n        // iterate through the 2 lists and only insert the ones in\r\n        // the inclusion list that aren't found in exclusion list.\r\n        const outputList = [];\r\n\r\n        let incI = 0;\r\n        let excI = 0;\r\n        while (incI < inclusionDataset.length && excI < exclusionDataset.length) {\r\n\r\n            if (inclusionDataset[incI].localeCompare(exclusionDataset[excI]) === -1) { // umatched inclusion tag, insert\r\n                outputList.push(inclusionDataset[incI]);\r\n                incI++;\r\n\r\n            } else if (inclusionDataset[incI].localeCompare(exclusionDataset[excI]) === 1) { // unmatched exclusion tag\r\n                excI++;\r\n\r\n            } else { // matching entry, so ignore inclusion data set entry and increment both\r\n                incI++;\r\n                excI++;\r\n\r\n            }\r\n\r\n        }\r\n        // flush inclusion entries if any remain\r\n        while (incI < inclusionDataset.length) {\r\n            outputList.push(inclusionDataset[incI]);\r\n            incI++;\r\n        }\r\n\r\n        return outputList;\r\n    }\r\n\r\n    /**\r\n     * This function iterates through both\r\n     * string arrays and performs a union (or)\r\n     * operation between the 2.\r\n     * \r\n     * I was figuring out how to use reduce, but then\r\n     * I found this post.\r\n     * https://medium.com/swlh/javascript-reduce-with-examples-570f1b51e854\r\n     * although I sorted by data to avoid having to use a hash set. This\r\n     * works as well as an alternative code.\r\n     * \r\n     * Note: we can assume that the lists in each string have unique tags.\r\n     * E.g. they appear only once, so we don't need to worry about duplicates.\r\n     * \r\n     * \r\n     * @param {string[][]} tagList \r\n     */\r\n    generateUnion(tagList) {\r\n        if (tagList.length === 0) {\r\n            return tagList;\r\n        }\r\n\r\n        return tagList.reduce((prev, curr) => {\r\n            const output = [];\r\n            let i = 0;\r\n            let j = 0;\r\n\r\n            while (i < prev.length && j < curr.length) {\r\n\r\n\r\n                if (prev[i].localeCompare(curr[j]) === -1) { // prev comes before curr\r\n                    output.push(prev[i]);\r\n                    i++;\r\n\r\n                } else if (prev[i].localeCompare(curr[j]) === 1) { // curr comes before prev\r\n                    output.push(curr[j])\r\n                    j++;\r\n\r\n                } else { // same entry found\r\n                    output.push(curr[i]);\r\n                    i++;\r\n                    j++;\r\n\r\n                }\r\n            }\r\n\r\n            while (i < prev.length) {\r\n                output.push(prev[i]);\r\n                i++;\r\n            }\r\n\r\n            while (j < prev.length) {\r\n                output.push(curr[j])\r\n                j++;\r\n            }\r\n\r\n            return output;\r\n        });\r\n        // Medium version\r\n        //return tagList.reduce((prev, curr) => [...new Set(first.concat(second))]);\r\n    }\r\n\r\n    generateIntersection(tagList) {\r\n        if (tagList.length === 0) {\r\n            return [];\r\n        }\r\n\r\n        return tagList.reduce((prev, curr) => {\r\n            const output = [];\r\n            let i = 0;\r\n            let j = 0;\r\n\r\n            while (i < prev.length && j < curr.length) {\r\n\r\n                if (prev[i].localeCompare(curr[j]) === -1) { // prev comes before curr\r\n                    i++;\r\n\r\n                } else if (prev[i].localeCompare(curr[j]) === 1) { // curr comes before prev\r\n                    j++;\r\n\r\n                } else { // same entry found\r\n                    output.push(prev[i]);\r\n                    i += 1;\r\n                    j += 1;\r\n\r\n                }\r\n            }\r\n\r\n            return output;\r\n        })\r\n    }\r\n\r\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import _typeof from \"./typeof.js\";\nimport assertThisInitialized from \"./assertThisInitialized.js\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return assertThisInitialized(self);\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nimport possibleConstructorReturn from \"./possibleConstructorReturn.js\";\nexport default function _createSuper(Derived) {\n  var hasNativeReflectConstruct = isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","/**\r\n * This is an abstract class used\r\n * to specify what values are required\r\n * to be able to use an object as a key\r\n * to pass it into the LRU Cache.\r\n */\r\nexport default class LRUKey{\r\n    constructor() {\r\n        this.hashCode = 1;\r\n    }\r\n\r\n    equals(other) {\r\n        if (other == null) {\r\n            return false;\r\n        }\r\n\r\n        return this.hashCode === other.hashCode;\r\n    }\r\n}","/**\r\n * Source: https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js\r\n * \r\n * This code comes from bryc. At least he said anyone can use it on stack overflow\r\n * https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\r\n * \r\n * Anyways, this is a string hash function. There is no special reason I decided to use this\r\n * hash function. It just seemed convenient. Given our application, we don't need a \r\n * cryptographic hash function, so security doesn't matter. Mostly just need a hash\r\n * function focused on speed and some degree of collision resiliance. If you don't\r\n * want to use this hash function, you can use MD5 instead. I'm not too sure how\r\n * fast it is, but it's a fair hash function to use in this situation.\r\n * \r\n * I'm not too sure why I put this in a separate file. there is no reason to do so, but oh well.\r\n * I think it might be that this hash function isn't really a post storage function, but\r\n * it's only use is in there. I'll keep it here for now in case I might use this for something\r\n * else.\r\n * \r\n * @param {string} str \r\n * @param {number} seed \r\n * @returns \r\n */\r\nexport const cyrb53 = function (str, seed = 0) {\r\n    let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;\r\n    for (let i = 0, ch; i < str.length; i++) {\r\n        ch = str.charCodeAt(i);\r\n        h1 = Math.imul(h1 ^ ch, 2654435761);\r\n        h2 = Math.imul(h2 ^ ch, 1597334677);\r\n    }\r\n    h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);\r\n    h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);\r\n    return 4294967296 * (2097151 & h2) + (h1 >>> 0);\r\n};\r\n\r\n/**\r\n * Required: cyr53. You can replace this with any other string hash function like MD5.\r\n * \r\n * This function generates a string hash for all entries of the array, then performs\r\n * a bitwise XOR operation between all entries to return a final concatenated result.\r\n * \r\n * This function is useful in unordered data that still needs the same hash value.\r\n * \r\n * based off of this: https://jameshfisher.com/2018/01/09/how-to-hash-multiple-values/\r\n */\r\nexport const unorderedArrayStringHash = function (array) {\r\n    let code = 0;\r\n    for (let index in array) {\r\n        const tag = array[index];\r\n        code = code ^ cyrb53(tag);\r\n    }\r\n    return code;\r\n}\r\n\r\n/**\r\n * Required: cyr53. You can replace this with any other string hash function like MD5.\r\n * \r\n * This function serializes the array into a string, then uses the string hash function\r\n * to generate a hash value. \r\n * \r\n * This function is useful for data where order matters. Also, to generally prevent\r\n * collisions between ordered data.\r\n */\r\nexport const orderedArrayStringHash = function (array) {\r\n    const serializedArray = JSON.stringify(array);\r\n    return cyrb53(serializedArray);\r\n}\r\n\r\n/**\r\n * I copied this from StackOverflow from https://stackoverflow.com/a/52657929\r\n * \r\n * The intention of this function is to create an asynchronous lock till\r\n * a condition is satisfied.\r\n * \r\n * @param {*} conditionFunction \r\n * @returns \r\n */\r\nexport const until = function (conditionFunction) {\r\n\r\n    const poll = resolve => {\r\n        if (conditionFunction()) resolve();\r\n        else setTimeout(_ => poll(resolve), 400);\r\n    }\r\n\r\n    return new Promise(poll);\r\n}","import LRUKey from \"./lru_key\";\r\nimport { orderedArrayStringHash, unorderedArrayStringHash } from \"./utils\";\r\n/**\r\n * This class stores the groupings. \r\n * \r\n * E.g. the individual tags for maybe a comic reading website. These tags\r\n * are stored in the format of\r\n *      tags: [\r\n *          [\"ongoing\", \"active\"],\r\n *          [\"potato\"],\r\n *          [\"english\"]\r\n *      ]\r\n * There is some degree of implied groupings for the first dimension (I'm refering\r\n * to the top most array) for each entry. The second dimension (I'm referring to the\r\n * array nested) is more of an unordered set.\r\n *\r\n * UPDATE: I've come to realize that you should assume that the arrays are organized\r\n * in sequence of\r\n *      1) typeGroups\r\n *      2) tagGroups\r\n *      3) programmingLanguageGroups\r\n *      4) publicationStatusGroups\r\n *      5) languageGroups\r\n * This ordering is implied and all string[][] require the first dimension\r\n * array values to come in this order. If it doesn't this program will break.\r\n * \r\n * This class encapsulates comparison, hasing, and storing grouped values. \r\n * \r\n * Also, this class is immutable.\r\n * \r\n * Additional Note: This class doesn't have to store the inclustion tags and\r\n * exclusion tags as 2D arrays. This can be collapsed to a single array\r\n * since usually tags won't intersect. However, you'll need to also update\r\n * post_storage.js to also store everything in a single hashmap then. As\r\n * far as I can think, introducing the 2d arrays introduce more complexity\r\n * for no reason. \r\n */\r\nexport default class CategoryGroup extends LRUKey {\r\n    /**\r\n     * \r\n     * @param {string[][]} inclusionTags - This is a list of tags included in the grouping.\r\n     *                                     We can assume that each value in the array are unique\r\n     *                                     with respect to the first dimension groups.\r\n     * @param {boolean} inclusionAnd \r\n     * @param {string[][]} exclusionTags \r\n     * @param {boolean} exclusionAnd \r\n     */\r\n    constructor(inclusionTags, inclusionAnd, exclusionTags, exclusionAnd) {\r\n        super();\r\n\r\n        // Sets the fields\r\n        this.iTags = inclusionTags;\r\n        this.iAnd = inclusionAnd;\r\n        this.eTags = exclusionTags;\r\n        this.eAnd = exclusionAnd;\r\n\r\n        // This was more readable a previous version, but it didn't work cause I didn't\r\n        // iterate the array properly, so I changed it to this. This is much more painful now.\r\n        // lol.\r\n        this.hashCode = orderedArrayStringHash(\r\n            [\r\n                this.iTags.map((list) => unorderedArrayStringHash(list)).reduce((acc, next) => {return acc^next}),\r\n                this.iAnd ? \"T\" : \"F\",\r\n                this.eTags.map((list) => unorderedArrayStringHash(list)).reduce((acc, next) => {return acc^next}),\r\n                this.eAnd ? \"T\" : \"F\"\r\n            ]\r\n        );\r\n\r\n\r\n        // This might not be the most secure way to hash together a 2D array of strings, but oh well.\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {CategoryGroup} otherCategoryGroup \r\n     */\r\n    equals(otherCategoryGroup) {\r\n\r\n        // makes sure other pointer is not null\r\n        if (otherCategoryGroup == null) {\r\n            return false;\r\n        }\r\n\r\n        // compares hash codes \r\n        if (otherCategoryGroup.hashCode !== this.hashCode) {\r\n            return false;\r\n        }\r\n\r\n        // compares of both inclusionAnd and exclusionAnd properties are the same\r\n        if ((this.iAnd !== otherCategoryGroup.iAnd) || (this.eAnd !== otherCategoryGroup.eAnd)) {\r\n            return false;\r\n        }\r\n\r\n        // Compares the inclusion/exclusion array's sizes are the same\r\n        if (this.iTags.length !== otherCategoryGroup.iTags.length || this.eTags.length !== otherCategoryGroup.eTags.length) {\r\n            return false;\r\n        }\r\n\r\n        // Compares inclusion tag's lists\r\n        if (!CategoryGroup.helperCompare2DMatrix(this.iTags, otherCategoryGroup.iTags)) {\r\n            return false;\r\n        }\r\n\r\n        // compares exclusion tag's lists\r\n        if (!CategoryGroup.helperCompare2DMatrix(this.eTags, otherCategoryGroup.eTags)) {\r\n            return false;\r\n        }\r\n\r\n        // if everything checks out.\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * This is a helper function used to compare \r\n     * the inclusionTags or exclusionTags arrays.\r\n     * This is used primarily in the compare() function.\r\n     * \r\n     * This function assumes arr1 and arr2 are arrays of\r\n     * unique values (e.g. no duplicate entries) and that\r\n     * they're unordered. This returns if both arr1 and arr2\r\n     * have the same string values. \r\n     * \r\n     * @param {string[][]} arr1 \r\n     * @param {string[][]} arr2 \r\n     */\r\n    static helperCompare2DMatrix(arr1, arr2) {\r\n        const tagGroupMap = new Map(); // maps the tag groups in the array\r\n\r\n        // populates the map\r\n        for (let index in arr1) {\r\n            const tagGroup = arr1[index];\r\n            const grpHash = unorderedArrayStringHash(tagGroup);\r\n\r\n            // If the hash of the tag group already exists, we \r\n            // can just append duplicate values in the hash map.\r\n            // otherwise, we just create a new entry in the hash map.\r\n            if (tagGroupMap.has(grpHash)) {\r\n                tagGroupMap.get(grpHash).push(tagGroup);\r\n            } else {\r\n                tagGroupMap.set(grpHash, [tagGroup]);\r\n            }\r\n        }\r\n\r\n        // checks the map\r\n        for (let index in arr2) { // other tag group iteration\r\n            const oTagGroup = arr2[index];\r\n            const grpHash = unorderedArrayStringHash(oTagGroup);\r\n\r\n            if (!tagGroupMap.has(grpHash)) {\r\n                return false;\r\n            }\r\n\r\n            // this iterates through the open map entry. If it finds\r\n            // a matching array to the current other Category Group array,\r\n            // then return true. Otherwise, keep searching.\r\n            let foundArray = false;\r\n            for (let mapEntry in tagGroupMap.get(grpHash)) {\r\n                if (CategoryGroup.compareUnorderedSets(oTagGroup, mapEntry)) {\r\n                    foundArray = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!foundArray) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n    /**\r\n     * This is a helper method for comparing if 2 unordered\r\n     * sets contain the same entries. This is used for comparing\r\n     * the 2nd dimension sets in the inclusionTags or exclusionTags\r\n     * arrays.\r\n     * \r\n     * This function uses a Set to compare the 2, so it's an O(n)\r\n     * memory space complexity and O(n) time complexity.\r\n     * \r\n     * @param {string[]} arr1 \r\n     * @param {string[]} arr2 \r\n     * @returns \r\n     */\r\n    static compareUnorderedSets(arr1, arr2) {\r\n\r\n        // Quick exit\r\n        if (arr1.length !== arr2.length) {\r\n            return false;\r\n        }\r\n\r\n        const hashMap = new Set();\r\n\r\n        for (let entry in arr1) {\r\n            hashMap.add(entry);\r\n        }\r\n\r\n        for (let entry in arr2) {\r\n            if (!hashMap.has(entry)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    get copy() {\r\n        const iTagsCopy = [];\r\n        const eTagsCopy = [];\r\n\r\n        for (let group in this.iTags) {\r\n            iTagsCopy.push([...group]);\r\n        }\r\n\r\n        for (let group in this.eTags) {\r\n            eTagsCopy.push([...group]);\r\n        }\r\n\r\n        return new CategoryGroup(iTagsCopy, this.inclusionAnd, eTagsCopy, this.exclusionAnd);\r\n    }\r\n\r\n}","import CategoryGroup from \"./category_group\";\r\nimport LRUKey from \"./lru_key\";\r\nimport { orderedArrayStringHash } from \"./utils\";\r\n\r\n/**\r\n * This class is a search input. \r\n * This stores a single search result.\r\n * The values are not meant to be mutated\r\n * once created. This is more of designed\r\n * like a package that doesn't change once\r\n * passed in from the UI. It's also meant\r\n * to be a key wrapper, since hashes aren't\r\n * perfect. This stores the original key and\r\n * hashes of it.\r\n * \r\n * Also, this class is immutable.\r\n */\r\nexport default class SearchInput extends LRUKey {\r\n\r\n    /**\r\n     * \r\n     * @param {string} keyword - the keyword the user searched by.\r\n     * @param {string} sortBy \r\n     * @param {boolean} ascending \r\n     * @param {string[][]} inclusionTags \r\n     * @param {boolean} inclusionAnd \r\n     * @param {string[][]} exclusionTags \r\n     * @param {boolean} exclusionAnd \r\n     */\r\n    constructor(keyword, sortBy, ascending, inclusionTags, inclusionAnd, exclusionTags, exclusionAnd) {\r\n        super();\r\n\r\n        // Initializes fields\r\n        this.keyword = keyword;\r\n        this.sortBy = sortBy;\r\n        this.ascending = ascending;\r\n\r\n        // Generates the Category Group\r\n        this.categoryGroup = new CategoryGroup(inclusionTags, inclusionAnd, exclusionTags, exclusionAnd);\r\n\r\n        // Generates the hash code\r\n        this.hashCode = orderedArrayStringHash([this.keyword, this.sortBy, this.ascending ? \"T\" : \"F\", this.categoryGroup.hashCode]);\r\n    }\r\n\r\n    equals(otherSearchInput) {\r\n        if (otherSearchInput == null) {\r\n            console.error(\"null comparison\");\r\n            return false;\r\n        }\r\n\r\n        // compare hash code\r\n        if (this.hashCode !== otherSearchInput.hashCode) {\r\n            return false;\r\n        }\r\n\r\n        // compare keyword\r\n        if (this.keyword !== otherSearchInput.keyword) {\r\n            return false;\r\n        }\r\n\r\n        // compare sortBy\r\n        if (this.sortBy !== otherSearchInput.sortBy) {\r\n            return false;\r\n        }\r\n\r\n        // compare ascending\r\n        if (this.ascending !== otherSearchInput.ascending) {\r\n            return false;\r\n        }\r\n\r\n        // compare groupings\r\n        return this.categoryGroup.equals(otherSearchInput.categoryGroupCopy);\r\n\r\n    }\r\n\r\n    /**\r\n     * This function takes an object will the same\r\n     * fields as a SearchInput, but adds the methods\r\n     * to prototype. \r\n     * \r\n     * The purpose of this is because when we pass\r\n     * these classes through the web worker. We lose\r\n     * all functions. This function restores those \r\n     * function values and allows us to use it like \r\n     * a class instead of a collection of values.\r\n     * \r\n     * @param {Object} reference\r\n     */\r\n    static addMethodsToDummy(reference) {\r\n        return new SearchInput(\r\n            reference.keyword,\r\n            reference.sortBy,\r\n            reference.ascending,\r\n            reference.categoryGroup.iTags,\r\n            reference.categoryGroup.iAnd,\r\n            reference.categoryGroup.eTags,\r\n            reference.categoryGroup.eAnd\r\n        );\r\n    }\r\n\r\n}","import PostStorage from \"../state/post_storage\";\r\nimport SearchInput from \"../state/search_input\";\r\n/**\r\n * WEB WORKER NOTES\r\n * Reference: https://webpack.js.org/guides/web-workers/\r\n * \r\n * There are a few tutorials online about creating web workers\r\n * in react or JavaScript. However, some of them are for just\r\n * JavaScript (e.g. we don't need to deal with webpack) or\r\n * just old and outdated solution (e.g. webpack already has\r\n * a method for creating web workers). As referenced in the\r\n * docs above, if we follow webpack's method for creating\r\n * web workers, we can easily import all necessary classes\r\n * and files directly into the web worker. \r\n * \r\n * IMPLEMENTATION\r\n * This web worker handles initialization of the search\r\n * pool, search function calls, and some LRU caching.\r\n * \r\n * Also, just to add a note. We'll be using a lot of self\r\n * references in this implementation, due to me storing\r\n * some fields in the thread's global state. \r\n */\r\n\r\n/**\r\n * Global fields for the web worker. We can assume\r\n * that the initialization will come first, and that\r\n * will trigger the self.initialized field.\r\n */\r\n// eslint-disable-next-line no-restricted-globals\r\nself.initialized = false;\r\n// eslint-disable-next-line no-restricted-globals\r\nself.postStore = null;\r\n\r\n/**\r\n * This is the primary web worker thread. It's\r\n * a single event caller that will run all passed\r\n * in actions in a queue.\r\n * \r\n * @param {Object} param0 \r\n */\r\n// eslint-disable-next-line no-restricted-globals\r\nself.onmessage = (message) => {\r\n\r\n    /**\r\n     * Initialization Sequence. Registers all JSON objects\r\n     * into the pool.\r\n     */\r\n    // eslint-disable-next-line no-restricted-globals\r\n    if (!self.initialized) {\r\n\r\n        // eslint-disable-next-line no-restricted-globals\r\n        self.initialized = true;\r\n        // eslint-disable-next-line no-restricted-globals\r\n        self.postStore = new PostStorage(message.data);\r\n\r\n        // eslint-disable-next-line no-restricted-globals\r\n        postMessage(self.postStore.getTags()); // returns the generated tag groups\r\n\r\n        /**\r\n         * Search Query Process. Will return the corresponding post information.\r\n         */\r\n    } else {\r\n\r\n        // Note: we needed to convert the passed in object, since passing\r\n        // objects copy their field, but lose their methods.\r\n\r\n        // eslint-disable-next-line no-restricted-globals\r\n        const result = self.postStore.search(SearchInput.addMethodsToDummy(message.data));\r\n\r\n        // eslint-disable-next-line no-restricted-globals\r\n        postMessage({key: message.data, value: result});\r\n    }\r\n\r\n};"],"names":["_arrayLikeToArray","arr","len","length","i","arr2","Array","_toConsumableArray","isArray","iter","Symbol","iterator","from","o","minLen","n","Object","prototype","toString","call","slice","constructor","name","test","TypeError","_classCallCheck","instance","Constructor","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","LRUNode","value","oPrev","oNext","hPrev","hNext","this","LRUCache","maxsize","startDummyNode","endDummyNode","size","table","fill","start","end","node","generateHashIndex","hashCode","equals","removeAndAddToStart","newNode","addToLinkedListHead","lastNode","sortFunctions","x","ascending","keyword","sort","a","b","aHit","stringHitCount","dateA","Date","parse","created","dateB","title","localeCompare","updated","searchStr","postObject","regexExpression","RegExp","replace","hit","index","match","pages","postElement","dfsCheckContent","regexExp","count","hasOwn","nestedPostEl","PostStorage","jsonObjects","unfilteredPosts","typeGroups","create","tagGroups","programmingLanguageGroups","publicationStatusGroups","languageGroups","obj","ty_lc","type","toLowerCase","push","tags","t_lc","programming_languages","pl_lc","s_lc","status","lg_lc","language","intersectionCache","keys","searchObject","intersectedData","retrieve","categoryGroup","generateIntersectionData","insert","sortBy","console","error","filteredDisplayList","post","array","row","column","tagSelections","entriesToMerge","iTags","typeTag","tagTag","pgTag","psTag","lgTag","inclusionDataset","helperGet2dArrayLength","iAnd","generateIntersection","generateUnion","eTags","exclusionDataset","eAnd","outputList","incI","excI","tagList","reduce","prev","curr","output","j","_setPrototypeOf","p","setPrototypeOf","bind","__proto__","_inherits","subClass","superClass","_getPrototypeOf","getPrototypeOf","_typeof","_possibleConstructorReturn","self","ReferenceError","_createSuper","Derived","hasNativeReflectConstruct","Reflect","construct","sham","Proxy","Boolean","valueOf","e","result","Super","NewTarget","arguments","apply","LRUKey","other","cyrb53","str","ch","seed","h1","h2","charCodeAt","Math","imul","unorderedArrayStringHash","code","tag","orderedArrayStringHash","serializedArray","JSON","stringify","CategoryGroup","inclusionTags","inclusionAnd","exclusionTags","exclusionAnd","map","list","acc","next","otherCategoryGroup","helperCompare2DMatrix","iTagsCopy","eTagsCopy","group","arr1","tagGroupMap","Map","tagGroup","grpHash","has","get","set","oTagGroup","foundArray","mapEntry","compareUnorderedSets","hashMap","Set","entry","add","SearchInput","otherSearchInput","categoryGroupCopy","reference","initialized","postStore","onmessage","message","search","addMethodsToDummy","data","postMessage","getTags"],"sourceRoot":""}